---------------------------------------------------------------------
------- USUWANIE TABEL JESLI ISTNIALY ORAZ ICH WIEZOW ---------------
----------------------------------------------------------------------

drop table limity cascade;
drop table przedmioty cascade;
drop table status_grupy cascade;
drop table typ_szkoly cascade;
drop table typ_kursu cascade;
drop table termin_zajec cascade;
drop table uzytkownicy cascade;
drop table poziomy cascade;
drop table ceny cascade;
drop table zajecia_uczniow cascade;
drop table terminy_zajec_grup cascade;
drop table daty_kursu cascade;
drop table grupy cascade;
drop table rodzaje_uzytkownikow;


----------------------------------------------------------------------------
------------------------------ TWORZENIE TABEL -----------------------------
----------------------------------------------------------------------------

--pierwsze bez kluczy obcych--

create table limity (
	id serial primary key,
	liczba integer unique not null 
);

create table przedmioty (
	id integer generated by default as identity primary key,
	nazwa text unique not null
);

create table status_grupy (
	id integer generated by default as identity primary key,
	opis text unique not null
);

create table typ_szkoly (
	id integer generated by default as identity primary key,
	nazwa text unique not null check (nazwa in ('podstawowa', 'ponadpodstawowa','nie dotyczy'))
);

create table typ_kursu (
	id integer generated by default as identity primary key,
	nazwa text unique not null
);

create table termin_zajec (
	id integer generated by default as identity primary key,
	dzien_tygodnia text not null check(
		dzien_tygodnia in ('poniedzialek', 'wtorek', 'sroda', 'czwartek', 'piatek', 'sobota')),
	godzina varchar(11) not null check(
		godzina in('15:00-15:45','16:00-16:45', '17:00-17:45', '18:00-18:45', '19:00-19:45', '20:00-20:45')),
	unique(dzien_tygodnia,godzina)
);

create table rodzaje_uzytkownikow(
	id integer generated by default as identity primary key,
	nazwa text unique not null check( nazwa in ('administrator', 'nauczyciel', 'uczen', 'stazysta'))
);

create table uzytkownicy (
	id integer generated by default as identity primary key,
	login varchar(30) unique not null,
	haslo varchar(20) not null,
	stopien_uprawnien_uzytkownika integer not null default (3) references rodzaje_uzytkownikow(id) on delete cascade on update cascade,
	imie varchar(20) not null,
	nazwisko varchar(20) not null,
	mail varchar(50) unique not null,
	id_typ_szkoly integer not null default (3) references typ_szkoly(id) on delete cascade on update cascade
);

-- tabele z jednym kluczem obcym--

create table poziomy (
	id integer generated by default as identity primary key,
	nazwa text unique not null,
	id_typ_szkoly integer not null references typ_szkoly(id) on delete cascade on update cascade
);


create table daty_kursu (
	id integer generated by default as identity primary key,
	poczatek_zapisow date not null,
	koniec_zapisow date not null check(koniec_zapisow>poczatek_zapisow),
	poczatek_zajec date not null,
	koniec_zajec date not null check(koniec_zajec>poczatek_zajec),
	id_typ_kursu integer not null references typ_kursu(id) on delete cascade on update cascade,
	unique(poczatek_zajec,koniec_zajec,poczatek_zapisow, koniec_zapisow,id_typ_kursu)
);


-- tabele z kilkoma kluczami obcymi --

create table ceny (
	id integer generated by default as identity primary key,
	id_limitu integer not null references limity(id) on delete cascade on update cascade,
	id_poziomu integer not null references poziomy(id) on delete cascade on update cascade,
	id_typu integer not null references typ_kursu(id) on delete cascade on update cascade,
	cena_za_kurs decimal(6,2) not null,
	unique(id_limitu,id_poziomu, id_typu)
);


create table grupy (
	id integer generated by default as identity primary key,
	nazwa text not null,
	id_limitu integer not null references limity(id) on delete restrict on update cascade,
	id_przedmiotu integer not null references przedmioty(id) on delete cascade on update cascade,
	id_nauczyciela integer references uzytkownicy(id) on delete set null on update cascade,
	id_daty_kursu integer not null references daty_kursu(id) on delete cascade on update cascade,
	id_poziomu integer not null references poziomy(id) on delete cascade on update cascade,
	id_status integer not null references status_grupy(id) on delete cascade on update cascade,
	unique(id_nauczyciela,id_daty_kursu,id_przedmiotu,id_status,id_poziomu,nazwa, id_limitu)
);

create table terminy_zajec_grup(
	id_termin_zajec integer references termin_zajec(id) on delete cascade on update cascade,
	id_grupy integer references grupy(id) on delete cascade on update cascade,
	primary key(id_termin_zajec, id_grupy)
);

create table zajecia_uczniow (
	id_ucznia integer references uzytkownicy(id) on delete cascade on update cascade,
	id_grupy integer references grupy(id) on delete cascade on update cascade,
	primary key(id_ucznia, id_grupy)
	
);


--------------------------------------------------------------------------------
-------------------------------- WIDOKI ----------------------------------------
--------------------------------------------------------------------------------

-- tabela nauczycieli, ktorzy aktualnie prowadza grupy --
create or replace view aktualnie_uczacy_nauczyciele as
select uzytkownicy.imie as imie, uzytkownicy.nazwisko as nazwisko, przedmioty.nazwa as przedmiot, grupy.nazwa as grupa
from grupy join uzytkownicy on (grupy.id_nauczyciela=uzytkownicy.id) join przedmioty on (grupy.id_przedmiotu=przedmioty.id) join status_grupy on (grupy.id_status=status_grupy.id)
where status_grupy.opis='aktywna';

-- grafik zajec aktywnych grup --
create or replace view aktualny_grafik_grup as
select grupy.nazwa as nazwa, przedmioty.nazwa as przedmiot, termin_zajec.dzien_tygodnia as dzien ,termin_zajec.godzina as godziny
from (((terminy_zajec_grup join grupy on (terminy_zajec_grup.id_grupy=grupy.id)) join termin_zajec on (terminy_zajec_grup.id_termin_zajec=termin_zajec.id)) join przedmioty on (grupy.id_przedmiotu=przedmioty.id)) join status_grupy on (grupy.id_status=status_grupy.id)
where status_grupy.opis='aktywna';

-- tabela grup planowanych z datami zapisow i limitami --
drop view aktualny_grafik_zapisow;
create or replace view aktualny_grafik_zapisow as
select grupy.nazwa as nazwa, przedmioty.nazwa as przedmiot, daty_kursu.poczatek_zapisow as poczatek_zapisow, daty_kursu.koniec_zapisow as koniec_zapisow, b.il_zapisanych as ilosc_zajetych_miejsc, limity.liczba as limit_miejsc
from grupy join daty_kursu on (grupy.id_daty_kursu=daty_kursu.id) join status_grupy on (grupy.id_status=status_grupy.id) join limity on (grupy.id_limitu=limity.id) join przedmioty on (grupy.id_przedmiotu=przedmioty.id) join (
	select grupy.id as id, count(id_grupy) as il_zapisanych
from grupy left join zajecia_uczniow on (grupy.id=zajecia_uczniow.id_grupy) join status_grupy on (grupy.id_status=status_grupy.id)
where status_grupy.opis='planowana'
group by id_grupy , grupy.id) as b on (grupy.id=b.id)
where status_grupy.opis='planowana';

-- tabela z terminami zajec dla grup planowanych --
create or replace view zapisy_dalsze_info as
select grupy.nazwa as nazwa_grupy, grupy.id as id,termin_zajec.dzien_tygodnia as dzien_zajec,termin_zajec.godzina as godziny_zajec, uzytkownicy.imie as imie_nauczyciela, uzytkownicy.nazwisko as nazwisko_nauczyciela 
from grupy left join terminy_zajec_grup on (grupy.id=terminy_zajec_grup.id_grupy) join status_grupy on (grupy.id_status=status_grupy.id) join uzytkownicy on (grupy.id_nauczyciela=uzytkownicy.id) join termin_zajec on (terminy_zajec_grup.id_termin_zajec=termin_zajec.id)
where status_grupy.opis='planowana';

-- tabela aktualnie rekrutujących grup (czyli takich gdzie nie ma zapelnionych wszystkich miejsc) --
create or replace view aktualnie_rekrutujace_grupy as
select grupy.nazwa as nazwa, przedmioty.nazwa as przedmiot, daty_kursu.poczatek_zapisow as poczatek_zapisow, daty_kursu.koniec_zapisow as koniec_zapisow
from grupy join daty_kursu on (grupy.id_daty_kursu=daty_kursu.id) join status_grupy on (grupy.id_status=status_grupy.id) join limity on (grupy.id_limitu=limity.id) join przedmioty on (grupy.id_przedmiotu=przedmioty.id) join (
	select grupy.id as id, count(id_grupy) as il_zapisanych
from grupy left join zajecia_uczniow on (grupy.id=zajecia_uczniow.id_grupy) join status_grupy on (grupy.id_status=status_grupy.id)
where status_grupy.opis='planowana'
group by id_grupy , grupy.id) as b on (grupy.id=b.id)
where status_grupy.opis='planowana' and b.il_zapisanych<limity.liczba;

-- aktualnie rek grupy id (widok pomocniczy, ktory jest potrzebny do przycisku z wyborem grup) --
create or replace view aktualnie_rekrutujace_grupy_id as
select grupy.id as id
from grupy join daty_kursu on (grupy.id_daty_kursu=daty_kursu.id) join status_grupy on (grupy.id_status=status_grupy.id) join limity on (grupy.id_limitu=limity.id) join przedmioty on (grupy.id_przedmiotu=przedmioty.id) join (
	select grupy.id as id, count(id_grupy) as il_zapisanych
from grupy left join zajecia_uczniow on (grupy.id=zajecia_uczniow.id_grupy) join status_grupy on (grupy.id_status=status_grupy.id)
where status_grupy.opis='planowana'
group by id_grupy , grupy.id) as b on (grupy.id=b.id)
where status_grupy.opis='planowana' and b.il_zapisanych<limity.liczba;

-- cennik (widok ladnego cenniku dla klientow)--
create or replace view ceny_do_ogladania as
select c1.nazwa_poziomu as poziom, c1.limit_miejsc as limit_miejsc, c1.cena as cena_za_kurs_podstawowy, c2.cena as cena_za_kurs_intensywny
from (select ceny.cena_za_kurs as cena, poziomy.nazwa as nazwa_poziomu, limity.liczba as limit_miejsc, typ_kursu.nazwa as nazwa_typ_kursu
from ceny join poziomy on (ceny.id_poziomu=poziomy.id) join limity on (ceny.id_limitu=limity.id) join typ_kursu on (ceny.id_typu=typ_kursu.id)) as c1, 
(select ceny.cena_za_kurs as cena, poziomy.nazwa as nazwa_poziomu, limity.liczba as limit_miejsc, typ_kursu.nazwa as nazwa_typ_kursu
from ceny join poziomy on (ceny.id_poziomu=poziomy.id) join limity on (ceny.id_limitu=limity.id) join typ_kursu on (ceny.id_typu=typ_kursu.id)) as c2
where c1.nazwa_poziomu=c2.nazwa_poziomu and c1.limit_miejsc=c2.limit_miejsc and c1.nazwa_typ_kursu='standardowy' and c2.nazwa_typ_kursu='intensywny'
order by 1,2;

-- ładny widok poziomow dla klientow --
create or replace view poziomy_do_ogladania as
select typ_szkoly.nazwa as typ_szkoly, poziomy.nazwa as poziom
from poziomy join typ_szkoly on (poziomy.id_typ_szkoly=typ_szkoly.id);

--proste widoki dla uczniów i nauczycieli
create or replace view nauczyciele as
select imie, nazwisko, mail from uzytkownicy
where stopien_uprawnien_uzytkownika = 2;

create or replace view uczniowie as
select imie, nazwisko, mail from uzytkownicy
where stopien_uprawnien_uzytkownika = 3;


-----------------------------------------------------------------------------------
----------------------------------- WYZWALACZE ------------------------------------
-----------------------------------------------------------------------------------

-- grupy (wyzwalacz sprawdzajacy czy uzytkownik, ktorego chcemy uczynic nauczycielem grupy, jest faktycznie nauczycielem) --

-- Tworzenie funkcji
drop function sprawdz_typ_uzytkownika cascade;
CREATE OR REPLACE FUNCTION sprawdz_typ_uzytkownika()
RETURNS TRIGGER AS $$
BEGIN
    IF (SELECT stopien_uprawnien_uzytkownika  FROM uzytkownicy WHERE id = NEW.id_nauczyciela) != 2 THEN
        RAISE EXCEPTION 'Nie mozna przypisac ucznia jako nauczyciela dla grupy.';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Tworzenie triggera
drop trigger trigger_sprawdz_typ_uzytkownika on grupy cascade;
CREATE TRIGGER trigger_sprawdz_typ_uzytkownika
BEFORE INSERT OR UPDATE ON grupy
FOR EACH ROW
EXECUTE FUNCTION sprawdz_typ_uzytkownika();


-- zajecia uczniow (wyzwalacz sprawdzajacy czy uzytkownik, ktorego chcemy zapisac na zajecia, jest uczniem)--

-- Tworzenie funkcji
CREATE OR REPLACE FUNCTION sprawdz_rodzaj_uzytkownika()
RETURNS TRIGGER AS $$
BEGIN
    IF (SELECT stopien_uprawnien_uzytkownika  FROM uzytkownicy WHERE id = NEW.id_ucznia) != 3 THEN
        RAISE EXCEPTION 'Nie mozna przypisać nauczyciela do grupy uczniów.';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE 'plpgsql';

-- Tworzenie triggera
drop trigger trigger_sprawdz_rodzaj_uzytkownika on zajecia_uczniow cascade;
CREATE TRIGGER trigger_sprawdz_rodzaj_uzytkownika
before insert or update on zajecia_uczniow
FOR EACH ROW
EXECUTE FUNCTION sprawdz_rodzaj_uzytkownika();

-- grupy (wyzwalacz sprawdzajacy czy przedmiot, ktory chcemy przypisac do nowego kursu, jest przedmiotem,
-- z ktorego mozna zdawac egzamin na odpowiednim poziomie, czyli czy jest przedmiotem maturalnym lub obowiazujacym do egzaminu osmioklasisty)--

-- Tworzenie funkcji
drop function przedmioty_szk_podstawowa cascade;
CREATE OR REPLACE FUNCTION przedmioty_szk_podstawowa()
RETURNS TRIGGER AS $$
BEGIN
    IF (((SELECT nazwa FROM poziomy WHERE id = NEW.id_poziomu) = 'egzamin osmioklasisty') AND 
	(NEW.id_przedmiotu not in (select id from przedmioty where nazwa in ('jezyk angielski','matematyka','jezyk polski','jezyk niemiecki')))) THEN
        RAISE EXCEPTION 'Firma nie prowadzi korepetycji z tego przedmiotu dla szkol podstawowych';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE 'plpgsql';

-- Tworzenie triggera
drop trigger trigger_przedmioty_szk_podstawowa on grupy cascade;
CREATE TRIGGER trigger_przedmioty_szk_podstawowa
before insert or update on grupy
FOR EACH ROW
EXECUTE PROCEDURE przedmioty_szk_podstawowa();

-- zajecia uczniow (wyzwalacze sprawdzajace czy uczen jest uprawniony do zapisu do grupy, czyli czy poziom kursu jest zgodny z typem szkoly ucznia) --

-- Tworzenie funkcji
drop function zgodny_poziom1 cascade;
CREATE OR REPLACE FUNCTION zgodny_poziom1()
RETURNS TRIGGER AS $$
BEGIN
    IF (SELECT id_typ_szkoly FROM uzytkownicy WHERE id = NEW.id_ucznia) = 1 AND 
	(SELECT id_poziomu FROM grupy WHERE id = NEW.id_grupy) = (SELECT id FROM POZIOMY WHERE nazwa = 'matura') THEN
        RETURN 'Uczen szkoly podstawowej nie moze zapisac sie na kurs maturalny';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE 'plpgsql';

-- Tworzenie triggera
drop trigger trigger_zgodny_poziom1 on zajecia_uczniow;
CREATE TRIGGER trigger_zgodny_poziom1
before insert or update on zajecia_uczniow
FOR EACH ROW
EXECUTE PROCEDURE zgodny_poziom1();

drop function zgodny_poziom2 cascade;
CREATE OR REPLACE FUNCTION zgodny_poziom2()
RETURNS TRIGGER AS $$
BEGIN
    IF (SELECT id_typ_szkoly FROM uzytkownicy WHERE id = NEW.id_ucznia) = 2 AND 
	(SELECT id_poziomu FROM grupy WHERE id = NEW.id_grupy) = (SELECT id FROM POZIOMY WHERE nazwa = 'egzamin_osmoklasisty') THEN
        RETURN 'Uczen szkoly ponadpodstawowej nie moze zapisac sie na kurs przygotowujacy do egzaminu osmoklasisty';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE 'plpgsql';

-- Tworzenie triggera
drop trigger trigger_zgodny_poziom2 on zajecia_uczniow;
CREATE TRIGGER trigger_zgodny_poziom2
before insert or update on zajecia_uczniow
FOR EACH ROW
EXECUTE PROCEDURE zgodny_poziom2();
